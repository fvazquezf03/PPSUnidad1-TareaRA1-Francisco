{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tarea PPS Unidad 0 - Francisco V\u00e1zquez","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>En esta tarea se documentan los procesos de:</p> <ul> <li>Esta documentaci\u00f3n corresponde a la Tarea Obligatoria RA1 de la Unidad 1  donde se analiza, depura, prueba y documenta completamente la aplicaci\u00f3n Lavadero de Coches.</li> </ul>"},{"location":"#indice","title":"\u00cdndice","text":"<ul> <li>Documentaci\u00f3n y prueba del programa</li> <li> Realizaci\u00f3n de los test unitarios de la aplicaci\u00f3n.</li> <li>Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno controlado</li> <li>Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes.</li> </ul>"},{"location":"%20Realizaci%C3%B3n%20de%20los%20test%20unitarios%20de%20la%20aplicaci%C3%B3n./Documentaci%C3%B3n%20del%20apartado%203/","title":"2. Realizaci\u00f3n de los test unitarios de la aplicaci\u00f3n.","text":""},{"location":"%20Realizaci%C3%B3n%20de%20los%20test%20unitarios%20de%20la%20aplicaci%C3%B3n./Documentaci%C3%B3n%20del%20apartado%203/#codigo-utilizado-en-los-unnitest","title":"C\u00f3digo utilizado en los unnitest:","text":"<ul> <li>Test 1: este el c\u00f3digo utilizado en el test 1</li> </ul> <ul> <li>Test2:este el c\u00f3digo utilizado en el test 2</li> </ul> <ul> <li>Test3:este el c\u00f3digo utilizado en el test 3</li> </ul> <ul> <li>Test4-8:este el c\u00f3digo utilizado en el test 4-8</li> </ul> <ul> <li>Test9-14:este el c\u00f3digo utilizado en el test 9-14</li> </ul>"},{"location":"%20Realizaci%C3%B3n%20de%20los%20test%20unitarios%20de%20la%20aplicaci%C3%B3n./Documentaci%C3%B3n%20del%20apartado%203/#apartado-3-a-partir-de-los-resultados-de-los-tests-se-deben-corregir-tambien-los-problemas-encontrados-en-el-codigo-hasta-que-todos-los-tests-sean-correctos","title":"Apartado 3. A partir de los resultados de los tests, se deben corregir tambi\u00e9n los problemas encontrados en el c\u00f3digo hasta que todos los tests sean correctos.","text":"<ol> <li>El primer error que me he encontrado es en archivo unittest.py es el siguiente:</li> <li>Causa El test llama a _hacer_lavado  el m\u00e9todo correcto que hay que poner es sin guiones bajos  hacerLavado:</li> </ol> <ul> <li>Soluci\u00f3n: En el test test_lavadero_unittest.py hay que cambiar lo siguiente:</li> </ul> <ol> <li>El segundo es error en el precio incorrecto:</li> <li>Causa: El test espera que un lavado con prelavado a mano y secado a mano costara 7,50 \u20ac, pero la  funci\u00f3n _cobrar() estaba sumando mal y devolv\u00eda 7,70 \u20ac.</li> </ol> <ul> <li>Soluci\u00f3n: Corregir los valores de la suma como vemos en la siguiente imagen:</li> </ul> <ol> <li>El tercer error hay un error l\u00f3gico en la secuencia de fases:</li> </ol> <ul> <li>Solucci\u00f3n: El flujo respete prelavado, rodillos, secado y encerado seg\u00fan las opciones seleccionadas:</li> </ul>"},{"location":"%20Realizaci%C3%B3n%20de%20los%20test%20unitarios%20de%20la%20aplicaci%C3%B3n./Documentaci%C3%B3n%20del%20apartado%203/#para-ejecutar-las-pruebas-hay-que-hacer-los-siguientes-pasos","title":"Para ejecutar las pruebas hay que hacer los siguientes pasos:","text":"<ol> <li>Hay que activar primero crear el ven  y despues activarlo</li> </ol> <ol> <li> <p>Ejecutar las pruebas: <pre><code>PYTHONPATH=src pytest  tests/test_lavadero_unittest.py -v\n</code></pre> </p> </li> <li> <p>Al terminar de corregir los fallos y a la hora de hacer los test tiene que salir que estan todas pasados:</p> </li> </ol> <p></p>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Documentaci%C3%B3n%20de%20Apartado%201%20y%202%20/","title":"1. Documentaci\u00f3n y prueba del programa","text":""},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Documentaci%C3%B3n%20de%20Apartado%201%20y%202%20/#apartado-1-jupyter-noteboock","title":"Apartado 1  jupyter noteboock:","text":"<ul> <li>En el siguiente enlace te llevar\u00e1 a la documentaci\u00f3n de Jupyter noteboock: Documetaci\u00f3n del programa en jupyter noteboock</li> </ul>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Documentaci%C3%B3n%20de%20Apartado%201%20y%202%20/#apartado-2-ejecuta-el-programa-mediante-las-opciones-de-ejecucion-y-depuracion-del-ide","title":"Apartado 2  Ejecuta el programa mediante las opciones de Ejecuci\u00f3n y Depuraci\u00f3n del IDE.:","text":"<ul> <li> <p>Como vemos en la imagen a la hora de ejecutar el programa nos da un error : </p> </li> <li> <p>El error encontrado es el siguiente: </p> </li> <li> <p>indica que la funci\u00f3n ejecutarSimulacion() requiere tres argumentos para solucionarlos es llamar a encerrado: </p> </li> </ul>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/","title":"Documentaci\u00f3n de la clase Lavadero","text":""},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#1-definicion-de-la-clase-y-constantes-de-fase","title":"1. Definici\u00f3n de la clase y constantes de fase","text":"<p>Este bloque crea la clase <code>Lavadero</code> y define las 9 fases posibles del t\u00fanel de lavado mediante constantes. El uso de constantes con nombres descriptivos mejora la legibilidad y evita n\u00fameros m\u00e1gicos en el c\u00f3digo.</p> <pre><code>class Lavadero:\n    \"\"\"\n    Simula el estado y las operaciones de un t\u00fanel de lavado de coches.\n    Cumple con los requisitos de estado, avance de fase y reglas de negocio.\n    \"\"\"\n    FASE_INACTIVO = 0\n    FASE_COBRANDO = 1\n    FASE_PRELAVADO_MANO = 2\n    FASE_ECHANDO_AGUA = 3\n    FASE_ENJABONANDO = 4\n    FASE_RODILLOS = 5\n    FASE_SECADO_AUTOMATICO = 6\n    FASE_SECADO_MANO = 7\n    FASE_ENCERADO = 8\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#2-constructor-init","title":"2. Constructor init","text":"<p>Inicializa todos los atributos privados del lavadero y llama a <code>terminar()</code> para dejarlo en estado inactivo desde el principio.</p> <pre><code>    def __init__(self):\n        \"\"\"\n        Constructor de la clase. Inicializa el lavadero.\n        Cumple con el requisito 1.\n        \"\"\"\n        self.__ingresos = 0.0\n        self.__fase = self.FASE_INACTIVO\n        self.__ocupado = False\n        self.__prelavado_a_mano = False\n        self.__secado_a_mano = False\n        self.__encerado = False\n        self.terminar()\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#3-propiedades-getters-de-solo-lectura","title":"3. Propiedades (getters) de solo lectura","text":"<p>Permiten acceder a los atributos internos de forma segura usando @property.</p> <pre><code>    @property\n    def fase(self):\n        return self.__fase\n\n    @property\n    def ingresos(self):\n        return self.__ingresos\n\n    @property\n    def ocupado(self):\n        return self.__ocupado\n\n    @property\n    def prelavado_a_mano(self):\n        return self.__prelavado_a_mano\n\n    @property\n    def secado_a_mano(self):\n        return self.__secado_a_mano\n\n    @property\n    def encerado(self):\n        return self.__encerado\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#4-metodo-terminar","title":"4. M\u00e9todo terminar()","text":"<p>Restaura el lavadero al estado inicial cuando termina cualquier lavado.</p> <pre><code>    def terminar(self):\n        self.__fase = self.FASE_INACTIVO\n        self.__ocupado = False\n        self.__prelavado_a_mano = False\n        self.__secado_a_mano = False\n        self.__encerado = False\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#5-metodo-hacerlavado","title":"5. M\u00e9todo hacerLavado()","text":"<p>Inicia un nuevo lavado con las opciones elegidas. Aplica las dos reglas de negocio principales: - No se puede empezar si est\u00e1 ocupado - El encerado solo es posible con secado a mano</p> <pre><code>    def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado):\n        \"\"\"\n        Inicia un nuevo ciclo de lavado, validando reglas de negocio.\n\n        :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3).\n        :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2).\n        \"\"\"\n        if self.__ocupado:\n            raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\")\n\n        if not secado_a_mano and encerado:\n            raise ValueError(\"No se puede encerar el coche sin secado a mano\")\n\n        self.__fase = self.FASE_INACTIVO\n        self.__ocupado = True\n        self.__prelavado_a_mano = prelavado_a_mano\n        self.__secado_a_mano = secado_a_mano\n        self.__encerado = encerado\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#6-metodo-privado-_cobrar","title":"6. M\u00e9todo privado _cobrar()","text":"<p>Calcula el precio del lavado actual seg\u00fan las opciones y lo suma a los ingresos totales.</p> <pre><code>    def _cobrar(self):\n        \"\"\"\n        Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8).\n        Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac)\n        \"\"\"\n        coste_lavado = 5.00\n\n        if self.__prelavado_a_mano:\n            coste_lavado += 1.50 \n\n        if self.__secado_a_mano:\n            coste_lavado += 1.20 \n\n        if self.__encerado:\n            coste_lavado += 1.00 \n\n        self.__ingresos += coste_lavado\n        return coste_lavado\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#7-metodo-avanzarfase","title":"7. M\u00e9todo avanzarFase()","text":"<p>Controla el avance paso a paso del lavado, gestionando todas las ramas posibles seg\u00fan las opciones contratadas.</p> <pre><code>    def avanzarFase(self):\n\n        if not self.__ocupado:\n            return\n\n        if self.__fase == self.FASE_INACTIVO:\n            coste_cobrado = self._cobrar()\n            self.__fase = self.FASE_COBRANDO\n            print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\")\n\n        elif self.__fase == self.FASE_COBRANDO:\n            if self.__prelavado_a_mano:\n                self.__fase = self.FASE_PRELAVADO_MANO\n            else:\n                self.__fase = self.FASE_ECHANDO_AGUA \n\n        elif self.__fase == self.FASE_PRELAVADO_MANO:\n            self.__fase = self.FASE_ECHANDO_AGUA\n\n        elif self.__fase == self.FASE_ECHANDO_AGUA:\n            self.__fase = self.FASE_ENJABONANDO\n\n        elif self.__fase == self.FASE_ENJABONANDO:\n            self.__fase = self.FASE_RODILLOS\n\n        elif self.__fase == self.FASE_RODILLOS:\n            if self.__secado_a_mano:\n                self.__fase = self.FASE_SECADO_AUTOMATICO \n\n            else:\n                self.__fase = self.FASE_SECADO_MANO\n\n        elif self.__fase == self.FASE_SECADO_AUTOMATICO:\n            self.terminar()\n\n        elif self.__fase == self.FASE_SECADO_MANO:\n\n            self.terminar() \n\n        elif self.__fase == self.FASE_ENCERADO:\n            self.terminar() \n\n        else:\n            raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\")\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#8-metodos-de-impresion-del-estado","title":"8. M\u00e9todos de impresi\u00f3n del estado","text":"<p>Permiten ver en pantalla el estado actual del lavadero de forma clara.</p> <pre><code>    def imprimir_fase(self):\n        fases_map = {\n            self.FASE_INACTIVO: \"0 - Inactivo\",\n            self.FASE_COBRANDO: \"1 - Cobrando\",\n            self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\",\n            self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\",\n            self.FASE_ENJABONANDO: \"4 - Enjabonando\",\n            self.FASE_RODILLOS: \"5 - Pasando rodillos\",\n            self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\",\n            self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\",\n            self.FASE_ENCERADO: \"8 - Encerando a mano\",\n        }\n        print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\")\n\n    def imprimir_estado(self):\n        print(\"----------------------------------------\")\n        print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\")\n        print(f\"Ocupado: {self.ocupado}\")\n        print(f\"Prelavado a mano: {self.prelavado_a_mano}\")\n        print(f\"Secado a mano: {self.secado_a_mano}\")\n        print(f\"Encerado: {self.encerado}\")\n        print(\"Fase: \", end=\"\")\n        self.imprimir_fase()\n        print(\"\\n----------------------------------------\")\n</code></pre>"},{"location":"Documentaci%C3%B3n%20y%20prueba%20del%20programa/Jupyter%20NotebookApartado1/#9-metodo-auxiliar-para-pruebas-ejecutar_y_obtener_fases","title":"9. M\u00e9todo auxiliar para pruebas (ejecutar_y_obtener_fases)","text":"<p>Funci\u00f3n de apoyo para pruebas unitarias que ejecuta un lavado completo y devuelve la lista de fases visitadas.</p> <pre><code>    # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real\n    # nos crea un array con las fases visitadas en un ciclo completo\n    def ejecutar_y_obtener_fases(self, prelavado, secado, encerado):\n        \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\"\n        self.hacerLavado(prelavado, secado, encerado)  # Corregido: era self.lavadero\n        fases_visitadas = [self.fase]\n\n        while self.ocupado:\n            if len(fases_visitadas) &gt; 15:\n                raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\")\n            self.avanzarFase()\n            fases_visitadas.append(self.fase)\n\n        return fases_visitadas\n</code></pre>"},{"location":"Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/","title":"3. Ejecuci\u00f3n de la aplicaci\u00f3n en un entorno controlado","text":""},{"location":"Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/#1-instalar-firejail-y-firetools","title":"1. Instalar Firejail y Firetools","text":"<p><pre><code># En Debian/Ubuntu\nsudo apt update\nsudo apt install -y firejail firetools\n</code></pre> - Captura de instalaci\u00f3n: </p> <ul> <li>Para saber que versi\u00f3n tiene : <pre><code># Verificar instalaci\u00f3n\nfirejail --version\n</code></pre> </li> </ul>"},{"location":"Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/#2-primero-preparar-el-firejail","title":"2. Primero preparar el firejail:","text":"<ul> <li>Si quieres que tu aplicaci\u00f3n acceda solo en una carpeta especifica: <pre><code>firejail --private=/home/ppsfran/Proyecto-Lavadero/\n</code></pre></li> </ul>"},{"location":"Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/Ejecuci%C3%B3n%20de%20la%20aplicaci%C3%B3n%20en%20un%20entorno%20controlado/#3segundo-prepara-el-entorno-para-poder-ejecutar-las-pruebas","title":"3.Segundo prepara el entorno para poder ejecutar las pruebas:","text":"<ol> <li>Creamos entorno virtual de Python</li> </ol> <pre><code>python3 -m venv sanbox\n</code></pre> <ol> <li>Activamos el entorno virtual:</li> </ol> <pre><code>source sanbox/bin/activate\n</code></pre> <ol> <li>Ejecutar el programa dentro de sanbox dentro de la carpeta aislada:</li> </ol> <pre><code>PYTHONPATH=src python3 main_app\n</code></pre>"},{"location":"Reflexi%C3%B3n%20sobre%20comparaci%C3%B3n%20de%20la%20infraestructura%20de%20seguridad%20de%20los%20lenguajes./Reflexi%C3%B3n%20c%C3%B3digo/","title":"Reflexi\u00f3n sobre medidas de seguridad en lenguajes de programaci\u00f3n","text":""},{"location":"Reflexi%C3%B3n%20sobre%20comparaci%C3%B3n%20de%20la%20infraestructura%20de%20seguridad%20de%20los%20lenguajes./Reflexi%C3%B3n%20c%C3%B3digo/#introduccion","title":"Introducci\u00f3n","text":"<p>En este texto reflexiono sobre las medidas de seguridad que incorporan algunos de los principales lenguajes de programaci\u00f3n y c\u00f3mo estas medidas influyen en la seguridad de las aplicaciones en producci\u00f3n. La reflexi\u00f3n sirve como entrada para el apartado 5 de la Tarea Obligatoria de la Unidad 1.</p>"},{"location":"Reflexi%C3%B3n%20sobre%20comparaci%C3%B3n%20de%20la%20infraestructura%20de%20seguridad%20de%20los%20lenguajes./Reflexi%C3%B3n%20c%C3%B3digo/#conclusion-personal","title":"Conclusi\u00f3n personal","text":"<p>En mi opini\u00f3n, no existe un \u00fanico \"lenguaje seguro\" por s\u00ed mismo: la seguridad es una combinaci\u00f3n de dise\u00f1o del lenguaje, ecosistema, herramientas y pr\u00e1cticas operativas. Si el objetivo es minimizar errores de memoria y concurrencia, Rust ofrece una ventaja clara por su modelo de propiedad y comprobaciones en compilaci\u00f3n. Si la prioridad es productividad con protecciones por defecto, un lenguaje gestionado como Java o C# es adecuado.</p> <p>Para aplicaciones que se van a analizar en sandboxing (ej. ejecuci\u00f3n de c\u00f3digo potencialmente inseguro o an\u00e1lisis de malware), mi recomendaci\u00f3n pr\u00e1ctica es:</p> <ul> <li>Usar entornos aislados (contenedores, Firejail, VMs) para cualquier c\u00f3digo no verificado.</li> <li>Emplear an\u00e1lisis est\u00e1tico y din\u00e1mico (fuzzing, sanitizers) cuando sea posible.</li> <li>Mantener control estricto de dependencias y pol\u00edticas de permisos.</li> </ul>"}]}